package ayu.edu.tr.iskolik.common.application.jasper;

import java.io.Serializable;
import java.sql.Connection;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import net.sf.jasperreports.engine.JRDataSource;
import net.sf.jasperreports.engine.JRException;
import net.sf.jasperreports.engine.data.JRBeanCollectionDataSource;
import org.apache.commons.lang3.NotImplementedException;

/**
 * A model class that represents a JasperReports report object. This model class
 * is intended to be used in association with the
 * {@link IskolikJasperReportsManager} utility class. Once the report object is
 * filled with necessary information, it is sent to TcmbJasperReportsManager,
 * which has static utility methods for displaying, saving and printing the
 * report. Some or all of the following fields should be set to not-null values
 * accordingly.
 * 
 * <MENU> <LI> <code>filePath</code> - path of the (jasper) report file
 * <u>relative</u> to the 'src/main/webapp' folder of the web project. The
 * extension of the file must be omitted. (e.g.
 * /SAGSISO/doktor/liste/DoktorHastaSayisi)
 * 
 * <LI> <code>dataList</code> - Collection of data that is to be listed in the
 * report. Can be a list of javabeans (HQL) or list of object arrays (SQL). Read
 * below for further discussion.
 * 
 * <LI> <code>fieldNames</code> - required only if the datasource is a list of
 * object arrays, which is usually the result of an ordinary SQL query. <LI>
 * <code>parameters</code> - required if the report has parameters <LI>
 * <code>subreportList</code> - required if the object has subreports. <LI>
 * <code>reportFormat</code> - HTML, PDF or XLS. Default value is HTML.
 * </MENU>
 * 
 * <br>
 * </br> An ordinary Hibernate HQL query returns a list of java beans. In that
 * case, the <code>fieldnames</code> field is <b>useless</b>, bacause for
 * each field X in the design of the jasper report, the value of the field is
 * evaluated easily by calling the getX() method of the javabeans in the
 * resultset. Ordinary SQL statements, on the other hand, return list of object
 * arrays. For example, suppose we have two relations Doctor(doctorId, name,
 * surname) and Patient(patientId, name, surname, doctorId ). Consider the
 * following SQL query that returns the number of patients each doctor has:
 * 
 * <pre>
 * 	SELECT (d.name + ' ' + d.surname) as NAME, COUNT(p.patientId) as PATIENT_COUNT
 * 	FROM Doctor d, Patient p
 * 	WHERE d.doctorId = p.doctorId
 * 	GROUP BY d.name 
 * </pre>
 * 
 * The resultset of this query contains a list of object arrays where each array
 * contains two fields: NAME and COUNT, of types string and integer,
 * respectively. For example, { ["Murat Ergin",99] , ["G\u00fclen Kaya",88] ,
 * ... , ["Nesrin Erol",77] } can be the result of this query. Jasper Reports
 * engine cannot map the fields in the report design to the arrays in the
 * resultset automatically. Therefore, to display this resultset properly in a
 * report, the <code>fieldNames</code> field should be set appropriately as
 * follows:
 * 
 * <pre>
 * <code>
 * 	List dataList = ...;
 * 
 * 	TcmbReport report = new TcmbReport();
 * 	report.setFilePath(&quot;/SAGSISO/doktor/liste/DoktorHastaSayisi&quot;);
 * 	report.setReportFormat(&quot;PDF&quot;);
 * 	...
 * 	report.setDataList(dataList);
 * 	rapor.setFieldNames(new String[] { &quot;NAME&quot;,&quot;PATIENT_COUNT&quot; });
 * 	...
 * 	TcmbJasperReportsManager.displayReport(request,response,report);
 * </code>
 * </pre>
 * 
 * The corresponding field names then can be used in the design of the
 * JasperReports report. For example, a field called "PATIENT_COUNT" in the
 * report design is populated with the second elements of the arrays in this
 * resultset.
 * 
 * <p>
 * The sample lists given below need not be generated by Hibernate. The same
 * rules apply to manually populated lists as well.
 * </p>
 * 
 * @see IskolikJasperReportsManager
 * 
 * @see JRDataSource
 * 
 * @author SAGSISO@ugem.tcmb.gov.tr
 * 
 * @version 1.0
 * 
 * @since August 2007
 */

public class IskolikReport implements Serializable {

	private static final long serialVersionUID = -7577313690585697308L;

	private String filePath; // Relative path of the physical report file
	private List<?> dataList;
	private String reportFormat;
	private Map<String, Object> parameters;
	private List<IskolikReport> subreportList;
	private String[] fieldNames;
	private JRDataSource dataSource;

	/**
	 * Default constructor.
	 * 
	 */
	public IskolikReport() {
		super();
		setReportFormat("PDF");
		setParameters(new HashMap<String, Object>());
		setSubreportList(new ArrayList<IskolikReport>(0));
		setDataList(null);
	}

	/**
	 * Returns a string representation of the TcmbReport object.
	 */
	public String toString() {

		StringBuffer result = new StringBuffer();
		result.append("TcmbReport[");
		result.append("filePath=").append(getFilePath()).append(", ");
		result.append("reportFormat=").append(getReportFormat()).append(", ");
		result.append("fieldnames=").append(getFieldNames()).append(", ");
		result.append("dataSource=").append(getDataSource()).append(", ");
		result.append("dataList=").append(getDataList()).append(", ");
		result.append("parameters=").append(getParameters()).append(", ");
		result.append("subreportList=").append(getSubreportList()).append(", ");
		result.append("]");
		return result.toString();
	}

	/**
	 * Compares the given TcmbReport object with <code>this</code> object. Two
	 * TcmbReport objects are equal if their <i>filePath</i>s are equal.
	 * 
	 * @param otherReport
	 *            a TcmbReport object, which will compared to <code>this</code>.
	 * 
	 * @return <code>true</code> if the two TcmbReport objects are equal,
	 *         <code>false</code> otherwise.
	 */
	public boolean equals(Object otherReport) {
		if (otherReport == this) {
			return true;
		}
		if (!(otherReport instanceof IskolikReport)) {
			return false;
		}
		IskolikReport other = (IskolikReport) otherReport;
		return (getFilePath() == null ? other.getFilePath() == null
				: getFilePath().equals(other.getFilePath()));
	}

	public int hashCode() {
		return HashCodeUtil.hash(HashCodeUtil.SEED, getFilePath());
	}

	/**
	 * @return <code>true</code> if there is any subreport, <code>false</code>
	 *         otherwise.
	 */
	public boolean hasSubreport() {
		return (getSubreportList().size() > 0);
	}

	public Object addReportParameter(String key, Object value) {
		return parameters.put(key, value);
	}

	public Object getReportParameter(String key) {
		return parameters.get(key);
	}

	public boolean addSubreport(IskolikReport subreport) {
		return subreportList.add(subreport);
	}

	public boolean removeSubreport(IskolikReport subreport) {
		return subreportList.remove(subreport);
	}

	public Connection getConnection() throws JRException {
		throw new NotImplementedException();
	}

	/**
	 * If the dataSource has been set manually by the client, then returns that
	 * datasource. Otherwise, examines the <code>TcmbReport</code> and returns
	 * either a {@link JRBeanCollectionDataSource} or
	 * {@link HibernateQueryResultDataSource} object appropriately.
	 */
	public JRDataSource getDataSource() {
		if (dataSource == null) {
			if (getDataList() != null) {
				if (getFieldNames() == null) {
					return new JRBeanCollectionDataSource(getDataList());
				} else {
					return new HibernateQueryResultDataSource(getDataList(),
							getFieldNames());
				}
			}
		}

		return dataSource;
	}

	/*
	 * getters - setters
	 */
	public List<?> getDataList() {
		return dataList;
	}

	public void setDataList(List<?> dataList) {
		this.dataList = dataList;
	}

	public String[] getFieldNames() {
		return fieldNames;
	}

	public void setFieldNames(String[] fieldNames) {
		this.fieldNames = fieldNames;
	}

	public String getFilePath() {
		return filePath;
	}

	public void setFilePath(String filePath) {
		this.filePath = filePath;
	}

	public Map<String, Object> getParameters() {
		return parameters;
	}

	public void setParameters(Map<String, Object> parameters) {
		this.parameters = parameters;
	}

	public String getReportFormat() {
		return reportFormat;
	}

	public void setReportFormat(String reportFormat) {
		this.reportFormat = reportFormat;
	}

	public List<IskolikReport> getSubreportList() {
		return subreportList;
	}

	public void setSubreportList(List<IskolikReport> subreportList) {
		this.subreportList = subreportList;
	}

	public void setDataSource(JRDataSource dataSource) {
		this.dataSource = dataSource;
	}
}